<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Docker从入门到精通 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="简介: docker是一个开源项目,基于go语言实现,遵循Apache2.0协议. 其目标是实现轻量级的操作系统虚拟化解决方案. docker的基础是Linux容器等技术. 在LXC的基础上docker的容器就像是操作一个快速轻量级的虚拟机一样简单. 以及依赖docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中,然后发不到流行的Linux机器上,也可以实现虚拟化开发. 容器">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker从入门到精通">
<meta property="og:url" content="http://example.com/2021/10/22/Docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="简介: docker是一个开源项目,基于go语言实现,遵循Apache2.0协议. 其目标是实现轻量级的操作系统虚拟化解决方案. docker的基础是Linux容器等技术. 在LXC的基础上docker的容器就像是操作一个快速轻量级的虚拟机一样简单. 以及依赖docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中,然后发不到流行的Linux机器上,也可以实现虚拟化开发. 容器">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/09/15/dPGvBtUb6Y2jRXp.png">
<meta property="og:image" content="https://i.loli.net/2021/09/15/hNxPRw2WaVnbOkt.png">
<meta property="og:image" content="https://i.loli.net/2021/09/15/SKmfu53sPY4n9qN.png">
<meta property="og:image" content="https://i.loli.net/2021/09/15/kFUnchDVPAr95N4.png">
<meta property="og:image" content="https://i.loli.net/2021/09/15/93gAUMEwJobhqXc.png">
<meta property="og:image" content="https://i.loli.net/2021/09/15/hqLtoJgf9iQalXv.png">
<meta property="og:image" content="https://i.loli.net/2021/09/15/D2x1jetbMUOfCYo.png">
<meta property="og:image" content="https://i.loli.net/2021/09/15/yqdUWhL5gQPrKOe.png">
<meta property="og:image" content="https://i.loli.net/2021/09/15/ue7pFU2Gr91NWmA.png">
<meta property="og:image" content="https://i.loli.net/2021/09/17/GrY2Ao6Fm3O7cWw.png">
<meta property="og:image" content="https://i.loli.net/2021/09/17/Ua6JYk3VtNP5vzC.png">
<meta property="article:published_time" content="2021-10-21T18:18:28.000Z">
<meta property="article:modified_time" content="2021-11-08T23:58:53.603Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/09/15/dPGvBtUb6Y2jRXp.png">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
  
<link rel="stylesheet" href="/css/index.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">Clover Tuan</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://dribbble.com/clovertuan" target="_blank" class="nav-icn iconfont icon-dribbble"></a>
          
        
          
            <a href="https://www.behance.net/clovertuan" target="_blank" class="nav-icn iconfont icon-behance"></a>
          
        
          
            <a href="http://clovertuan.lofter.com/" target="_blank" class="nav-icn iconfont icon-lofter"></a>
          
        
          
            <a href="https://www.instagram.com/clovertuan/" target="_blank" class="nav-icn iconfont icon-instagram"></a>
          
        
          
            <a href="https://github.com/cloverTuan" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/about" class="nav-menu ">ABOUT</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">Docker从入门到精通</h2>
  <p class="sub">Oct 22, 2021</p>
  <article class="content">
    <p>简介: docker是一个开源项目,基于go语言实现,遵循Apache2.0协议. 其目标是实现轻量级的操作系统虚拟化解决方案. docker的基础是Linux容器等技术. 在LXC的基础上docker的容器就像是操作一个快速轻量级的虚拟机一样简单. 以及依赖docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中,然后发不到流行的Linux机器上,也可以实现虚拟化开发. 容器是完全使用沙箱机制,相互之间不会有任何接口, 更重要的是容器性能开销极低.</p>
<h2 id="一、为什么使用Docker"><a href="#一、为什么使用Docker" class="headerlink" title="一、为什么使用Docker"></a>一、为什么使用Docker</h2><h3 id="1-Docker容器虚拟化的好处"><a href="#1-Docker容器虚拟化的好处" class="headerlink" title="1. Docker容器虚拟化的好处"></a>1. Docker容器虚拟化的好处</h3><p>在云时代，开发者创建的应用必须要能很方便地在网络上传播，也就是说应用必须脱离底层物理硬件的限制；同时必须满足“任何时间任何地点”可获取可使用的特点。因此，开发者们需要一种新型的创建分布式应用程序的方式，快速分发部署，而这正是Docker所能够提供的最大优势。Docker提供了一种更为聪明的方式，通过容器来打包应用、解耦应用和运行平台。这意味着迁移的时候，只需要在新的服务器上启动需要的容器就可以了，无论新旧服务器是否是同一类别的平台。这无疑帮助我们节约了大量的宝贵时间，并降低部署过程出现问题的风险。</p>
<h3 id="2-Docker在开发和运维中的优势"><a href="#2-Docker在开发和运维中的优势" class="headerlink" title="2. Docker在开发和运维中的优势"></a>2. Docker在开发和运维中的优势</h3><p>对于开发和运维人员来说，最梦寐以求的效果可能就是一次创建和配置，之后可以在任意地方、任意时间让应用正常运行，而Docker恰恰可以实现这一中级目标。具体来说，在开发和运维过程中，Docker具有以下几个方面的优势：</p>
<p><strong>更快的交付和部署：</strong>使用Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完之后，测试和运维人员可以直接使用完全相同的环境来部署代码。只要是开发测试过的代码，就可以确保在生产环境无缝运行。Docker可以快速创建和删除容器，实现快速迭代，节约开发、测试及部署的时间。</p>
<p><strong>更高效的利用资源：</strong>运行Docker容器不需要额外的虚拟化管理程序的支持，Docker是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低，与传统的虚拟机方式相比，Docker的性能要提高1 ü ~ 2个数量级。</p>
<p><strong>更轻松的迁移和扩展：</strong>Docker容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑等等，同时支持主流的操作系统发行版本。这种兼容性能让用户可以在不同的平台之间轻松的迁移应用。</p>
<p><strong>更轻松的管理和更新：</strong>使用Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</p>
<h3 id="3-Docker与虚拟机的比较"><a href="#3-Docker与虚拟机的比较" class="headerlink" title="3. Docker与虚拟机的比较"></a>3. Docker与虚拟机的比较</h3><p> 作为一种轻量级的虚拟化方式，Docker在运行应用上跟传统的虚拟机的方式相比具有如下显著优势：</p>
<ul>
<li><p>Docker容器启动很快，启动和停止可以实现秒级，相比传统的虚拟机方式（分钟级）要快速很多。</p>
</li>
<li><p>Docker容器对系统资源需求很少，一台主机上可以同时运行数千个Docker容器。</p>
</li>
<li><p>Docker通过类似git设计理念的操作来方便用户获取、分发和更新应用镜像，存储复用，增量更新。</p>
</li>
<li><p>Docker通过Dockerfile支持灵活的自动化创建和部署机制，可以提高工作效率，并标准化流程。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>特性</strong></th>
<th align="center"><strong>容器</strong></th>
<th align="center"><strong>虚拟机</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">启动速度</td>
<td align="center">秒级</td>
<td align="center">分钟级</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="center">接近原生</td>
<td align="center">较好</td>
</tr>
<tr>
<td align="center">内存</td>
<td align="center">MB级</td>
<td align="center">GB级</td>
</tr>
<tr>
<td align="center">硬盘适应</td>
<td align="center">MB级</td>
<td align="center">GB级</td>
</tr>
<tr>
<td align="center">运行密度</td>
<td align="center">单台主机支持上千个</td>
<td align="center">单台主机支持几个</td>
</tr>
<tr>
<td align="center">隔离性</td>
<td align="center">安全隔离</td>
<td align="center">完全隔离</td>
</tr>
<tr>
<td align="center">迁移</td>
<td align="center">优秀</td>
<td align="center">一般</td>
</tr>
</tbody></table>
<h2 id="二、Docker与虚拟化"><a href="#二、Docker与虚拟化" class="headerlink" title="二、Docker与虚拟化"></a>二、Docker与虚拟化</h2><p>Docker以及其他容器技术，都属于操作系统虚拟化范畴，操作系统细腻化最大的特点就是不需要额外的supervisor支持。Docker虚拟化方式之所以有众多优势，跟操作系统虚拟化技术自身的设计和实现分不开。</p>
<p><img src="https://i.loli.net/2021/09/15/dPGvBtUb6Y2jRXp.png" alt="image-20210915120033822"></p>
<h2 id="三、Docker概念和使用"><a href="#三、Docker概念和使用" class="headerlink" title="三、Docker概念和使用"></a>三、Docker概念和使用</h2><p>Docker中有三个核心概念：镜像、容器和仓库。因此，准确把握这三大概念对于掌握Docker技术尤为重要。</p>
<ul>
<li><p>镜像（Image）</p>
<p>Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</p>
</li>
<li><p>容器（Container）</p>
<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
</li>
<li><p>仓库（Repository）</p>
</li>
<li><p>用来保存镜像的仓库。当我们构建好自己的镜像之后，需要存放在仓库中，当我们需要启动一个镜像时，可  以在仓库中下载下来。</p>
</li>
</ul>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>Docker引擎是使用Docker容器的核心组件，可以在主流的操作系统和云平台上使用，包括Linux操作系统、MacOSS和Windows系统上。用户可以访问Docker官网（<a target="_blank" rel="noopener" href="https://www.docker.com/get-started%EF%BC%89%E5%8E%BB%E8%8E%B7%E5%8F%96Docker%E5%AE%89%E8%A3%85%E5%8C%85">https://www.docker.com/get-started）去获取Docker安装包</a></p>
<h4 id="1-1-第一个docker实例"><a href="#1-1-第一个docker实例" class="headerlink" title="1.1 第一个docker实例"></a>1.1 第一个docker实例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@alvin-test-os:~<span class="comment"># docker run -d --rm --name nginx -p 80:80 nginx</span></span><br><span class="line">Unable to find image <span class="string">&#x27;nginx:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">bb79b6b2107f: Pull complete </span><br><span class="line">5a9f1c0027a7: Downloading [==============&gt;               ]  7.457MB/26.49MB</span><br><span class="line">5a9f1c0027a7: Downloading [======================&gt;      ]  12.17MB/26.49MB</span><br><span class="line">166a2418f7e8: Download complete </span><br><span class="line">1966ea362d23: Download complete </span><br></pre></td></tr></table></figure>

<h3 id="2-使用Docker镜像"><a href="#2-使用Docker镜像" class="headerlink" title="2. 使用Docker镜像"></a>2. 使用Docker镜像</h3><p>docker镜像是docker中三大概念之一，其主要作用是作为启动容器的模板。</p>
<h4 id="2-1-获取镜像"><a href="#2-1-获取镜像" class="headerlink" title="2.1 获取镜像"></a>2.1 获取镜像</h4><p>镜像是运行容器的模板，官方Docker Hub 仓库已经提供了许多镜像共开发者使用。如果我们需要获取某个镜像则可以去docker仓库下载所需的镜像。</p>
<p>下载镜像的格式：docker pull [仓库的URL]&#x2F;[名称空间]&#x2F;[仓库的名称]:[版本号]</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@alvin-test-os ~]<span class="comment"># docker pull nginx:1.17</span></span><br><span class="line">1.17: Pulling from library/nginx</span><br><span class="line">afb6ec6fdc1c: Pull complete</span><br><span class="line">b90c53a0b692: Pull complete</span><br><span class="line">11fa52a0fdc0: Pull complete</span><br><span class="line">Digest: sha256:6fff55753e3b34e36e24e37039ee9eae1fe38a6420d8ae16ef37c92d1eb26699</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> nginx:1.17</span><br><span class="line">docker.io/library/nginx:1.17</span><br></pre></td></tr></table></figure>

<h4 id="2-2-查看镜像信息"><a href="#2-2-查看镜像信息" class="headerlink" title="2.2 查看镜像信息"></a>2.2 查看镜像信息</h4><p>镜像主要包括镜像文件、镜像tag以及镜像详细信息等等</p>
<h5 id="2-2-1-镜像列表"><a href="#2-2-1-镜像列表" class="headerlink" title="2.2.1 镜像列表"></a>2.2.1 镜像列表</h5><p>使用docker images 或 docker images ls命令可以列举本地主机上已有镜像的基本信息。</p>
<p><img src="https://i.loli.net/2021/09/15/hNxPRw2WaVnbOkt.png" alt="image-20210915121829565"></p>
<p>列举信息中，可以看到几个字段信息：</p>
<ul>
<li><p>镜像来源：来自哪个仓库. docker.io&#x2F;halohub&#x2F;halo</p>
</li>
<li><p>镜像标签：latest</p>
</li>
<li><p>镜像ID：例如 caebc1d425f9</p>
</li>
<li><p>镜像创建时间：例如：7 weeks ago</p>
</li>
<li><p>镜像大小：326 MB</p>
</li>
</ul>
<p>其中镜像的ID信息十分重要，它唯一标识了镜像。在使用镜像ID的时候，一般可以使用该ID的前若干个字符组成的可区分串来替代完整的ID。</p>
<p>TAG信息用于标记来自同一个仓库的不同镜像。TAG在同一个仓库中是唯一的。</p>
<p>镜像大小信息只是表示了该镜像的逻辑体积大小，实际上由于相同的镜像层本地只会存储一份，物理上占用的存储空间会小于各镜像逻辑体积之和。</p>
<p>image子命令主要支持如下选项:</p>
<ul>
<li><p>-a 列出所有(包括临时文件)镜像文件</p>
</li>
<li><p><img src="https://i.loli.net/2021/09/15/SKmfu53sPY4n9qN.png" alt="image-20210915124049820"></p>
</li>
<li><p>-digests&#x3D;true|false: 列出镜像的数字摘要值</p>
<p><img src="https://i.loli.net/2021/09/15/kFUnchDVPAr95N4.png" alt="image-20210915124123621"></p>
</li>
<li><p>-q: 仅显示ID信息</p>
<p><img src="https://i.loli.net/2021/09/15/93gAUMEwJobhqXc.png" alt="image-20210915124222005"></p>
</li>
</ul>
<h5 id="2-2-2-为镜像添加tag"><a href="#2-2-2-为镜像添加tag" class="headerlink" title="2.2.2 为镜像添加tag"></a>2.2.2 为镜像添加tag</h5><p>为了方便后续工作使用特定的镜像,还可与你docker tag命令为本地的镜像添加标签</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag halo:latest myhalo:latest</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-使用inspect命令查看详细信息"><a href="#2-2-3-使用inspect命令查看详细信息" class="headerlink" title="2.2.3 使用inspect命令查看详细信息"></a>2.2.3 使用inspect命令查看详细信息</h5><p>使用<code>docker inspect</code>命令获取镜像的详细信息, 包括PID、作者、架构等等</p>
<p><img src="https://i.loli.net/2021/09/15/hqLtoJgf9iQalXv.png" alt="image-20210915125327938"></p>
<p>2.2.4 使用history命令查看镜像历史</p>
<p><code>docker history [id]</code></p>
<p><img src="https://i.loli.net/2021/09/15/D2x1jetbMUOfCYo.png" alt="image-20210915125730417"></p>
<blockquote>
<p>注意：有些构建信息过长，可以使用–no-trunc选项来输出完整信息。</p>
</blockquote>
<h5 id="2-2-5-搜索镜像"><a href="#2-2-5-搜索镜像" class="headerlink" title="2.2.5 搜索镜像"></a>2.2.5 搜索镜像</h5><p><code>docker search [option] name</code></p>
<ul>
<li>-f: 过滤输出内容</li>
<li>– limit: 限制输出结果</li>
<li>–no-trunc: 不截断输出内容</li>
</ul>
<p><strong>输出参数释义</strong></p>
<ul>
<li><p>NAME: 镜像仓库源的名称</p>
</li>
<li><p>DESCRIPTION: 镜像的描述</p>
</li>
<li><p>OFFICIAL: 是否 docker 官方发布</p>
</li>
<li><p>stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</p>
</li>
<li><p>AUTOMATED: 自动构建。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/09/15/yqdUWhL5gQPrKOe.png" alt="image-20210915130725482"></p>
<h5 id="2-2-6-删除和清理镜像"><a href="#2-2-6-删除和清理镜像" class="headerlink" title="2.2.6 删除和清理镜像"></a>2.2.6 删除和清理镜像</h5><p>在Docker中,删除镜像主要使用rmi子命令, 清理镜像主要使用prune子命令</p>
<h6 id="2-2-6-1-使用标签删除镜像"><a href="#2-2-6-1-使用标签删除镜像" class="headerlink" title="2.2.6.1 使用标签删除镜像"></a>2.2.6.1 使用标签删除镜像</h6><p><code>docker rmi halo </code> or  <code>docker halo rm</code></p>
<ul>
<li>-f 强制删除</li>
</ul>
<h6 id="2-2-6-2-清理镜像"><a href="#2-2-6-2-清理镜像" class="headerlink" title="2.2.6.2 清理镜像"></a>2.2.6.2 清理镜像</h6><p>使用一段时间之后，docker会产生很多临时文件，以及一些没有被使用的镜像， 我们可以通过<code>docker image prune</code>命令来进行清理。</p>
<ul>
<li>-a 删除所有无用的镜像,不光是临时镜像</li>
</ul>
<h5 id="2-2-7-构建镜像"><a href="#2-2-7-构建镜像" class="headerlink" title="2.2.7 构建镜像"></a>2.2.7 构建镜像</h5><p>构建镜像一般有三种情况，基于容器导入、基于本地模板导入、基于Dockerfile创建，本章主讲基于容器保存镜像和本地保存镜像导入。</p>
<h6 id="2-2-7-1-基于容器保存"><a href="#2-2-7-1-基于容器保存" class="headerlink" title="2.2.7.1 基于容器保存"></a>2.2.7.1 基于容器保存</h6><p><code>docker [container id] commit</code></p>
<p>主要参数:</p>
<table>
<thead>
<tr>
<th>-a</th>
<th>作者信息</th>
</tr>
</thead>
<tbody><tr>
<td>-m</td>
<td>提交信息</td>
</tr>
<tr>
<td>-p</td>
<td>提交时，暂停容器运行</td>
</tr>
</tbody></table>
<p>启动一个容器、修改并保存</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@alvin-test-os ~]<span class="comment"># docker run -d -it centos /bin/bash</span></span><br><span class="line">Unable to find image <span class="string">&#x27;centos:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">3c72a8ed6814: Pull complete</span><br><span class="line">Digest: sha256:76d24f3ba3317fa945743bb3746fbaf3a0b752f10b10376960de01da70685fbd</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:latest</span><br><span class="line">820a17fe3935938b0d4208797f165db22e205e2a15d6dd053b4aeedbcba6cb12</span><br><span class="line">[root@alvin-test-os ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                                                                            COMMAND                  CREATED              STATUS              PORTS                    NAMES</span><br><span class="line">820a17fe3935        centos                                                                           <span class="string">&quot;/bin/bash&quot;</span>              About a minute ago   Up About a minute                            happy_kare</span><br><span class="line">[root@alvin-test-os ~]<span class="comment"># docker exec 820a17fe3935 touch test</span></span><br><span class="line">[root@alvin-test-os ~]<span class="comment"># docker  commit -m &quot;Add a file&quot; -a &quot;Alvin&quot; 820a17fe3935 centos:v1</span></span><br><span class="line">sha256:407b93005a8f27cd7eba5a10077994cf27c7a978e542fcf5b85a9caed0003bc9</span><br><span class="line">[root@alvin-test-os ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                        TAG                              IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                                            v1                               407b93005a8f        4 seconds ago       215MB</span><br></pre></td></tr></table></figure>

<h6 id="2-2-7-2-基于本地模板导入"><a href="#2-2-7-2-基于本地模板导入" class="headerlink" title="2.2.7.2 基于本地模板导入"></a>2.2.7.2 基于本地模板导入</h6><p>用户也可以将保存的镜像传到另一台电脑上,另一台计算机就可以导入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ubuntu-18.04-x86_64-minimal.tar.gz | docker import - ubuntu:18.04</span><br></pre></td></tr></table></figure>

<h5 id="2-2-8-保存镜像"><a href="#2-2-8-保存镜像" class="headerlink" title="2.2.8 保存镜像"></a>2.2.8 保存镜像</h5><p>有时我们需要将一台电脑上的镜像复制到另一台电脑上使用，除了可以借助仓库外，还可以直接将镜像保存成一个文件，再拷贝到另一台电脑上导入使用。</p>
<p>对于镜像的导出和导入，Docker 提供了两种方案，下面分别进行介绍。</p>
<h6 id="2-2-8-1-使用export和import"><a href="#2-2-8-1-使用export和import" class="headerlink" title="2.2.8.1 使用export和import"></a>2.2.8.1 使用export和import</h6><p>export和import的针对点是容器,将本机的容器导出为镜像包</p>
<ul>
<li><p>使用export 保存容器为镜像</p>
<p><img src="https://i.loli.net/2021/09/15/ue7pFU2Gr91NWmA.png"></p>
</li>
<li><p>使用import导入包为镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@linux ~]<span class="comment"># docker import halo.tar test/halo:v1</span></span><br><span class="line">sha256:02107323de1b074c5d2034b01eff855fec5922b45776c2721882d100ba6dd15b</span><br><span class="line">[root@linux docs]<span class="comment"># docker images | grep test</span></span><br><span class="line"><span class="built_in">test</span>/halo                                                        v1                         02107323de1b        22 seconds ago      131MB</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="2-2-8-2-使用save和load"><a href="#2-2-8-2-使用save和load" class="headerlink" title="2.2.8.2 使用save和load"></a>2.2.8.2 使用save和load</h6><p>save和load的针对的点事镜像,将本机的镜像导入,导出为镜像包</p>
<ul>
<li><p>使用save保存镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@linux ~]<span class="comment"># docker save 6858809bf669 &gt; halo.tar</span></span><br><span class="line">[root@linux ~]<span class="comment"># ll | grep halo</span></span><br><span class="line">-rw-r--r-- 1 root root   1458176 9月  17 21:01 halo.tar</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用save保存多个镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linux ~]<span class="comment"># docker save -o test.tar busybox nginx:1.18.0</span></span><br><span class="line">[root@linux ~]<span class="comment"># docker load &lt; test.tar</span></span><br><span class="line">Loaded image: busybox:latest</span><br><span class="line">Loaded image: nginx:1.18.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用load导入镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linux ~]<span class="comment"># docker load &lt; busybox.tar[root@linux ~]# docker load -i busybox.tarLoaded image ID: sha256:6858809bf669cc5da7cb6af83d0fae838284d12e1be0182f92f6bd96559873e3[root@instance-gvpb80ao docs]# docker images | grep 685880busybox                                                           latest                     6858809bf669        2 weeks ago         1.23MB</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>两种方案的区别</strong></p>
<ul>
<li><p>export导出的镜像文件体积小于save保存的镜像</p>
</li>
<li><p>docker import 可以为镜像指定新名称,docker load不能对载入的镜像重命名</p>
</li>
<li><p>docker export不支持将多个镜像打包到一个tar文件中买单时docker save支持</p>
</li>
<li><p>export导出(import导入)是根据容器拿到的镜像,在导入的时候会丢失镜像多有的历史记录和元数据信息(即今保存容器当时的快照状态),所以无法进行回滚操作</p>
<p>save保存(load加载)的镜像, 没有丢失镜像的历史,可以回滚到之前的层(layer)</p>
</li>
<li><p>同时他们之间的应用场景也是不一样的</p>
<ul>
<li><p>docker export的应用场景:</p>
<p>主要是用来制作基础镜像,比如我们从一个ubuntu镜像启动一个容器,然后安装一些软件和进行一些设置后,使用docker export保存一个基础镜像. 然后把这个镜像分发给其他人使用,比如作为基础的开发环境.</p>
</li>
<li><p>docker save的应用场景:</p>
<p>如果我们的应用shiyongdocker-compose.yml编排的多个镜像组合,但是我们要部署的客户端服务器不能连接外网. 这是后悔我们可以使用docker save将用到的镜像打个包,然后拷贝到客户端服务器上使用,docker load载入</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-使用Docker容器"><a href="#3-使用Docker容器" class="headerlink" title="3. 使用Docker容器"></a>3. 使用Docker容器</h3><h4 id="3-1-创建容器"><a href="#3-1-创建容器" class="headerlink" title="3.1 创建容器"></a>3.1 创建容器</h4><p>在Docker中,真正对外提供服务的还是容器, 我们需要了解如何创建容器</p>
<p>格式: <code>docker run [option] image [cmd]</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Linux ~]<span class="comment"># docker run -d --name nginx -p 80:80 nginxUnable to find image &#x27;nginx:latest&#x27; locallylatest: Pulling from library/nginx852e50cd189d: Pull completea29b129f4109: Pull completeb3ddf1fa5595: Pull completec5df295936d3: Pull complete232bf38931fc: Pull completeDigest: sha256:c3a1592d2b6d275bef4087573355827b200b00ffc2d9849890a4f3aa2128c4aeStatus: Downloaded newer image for nginx:latest6381d29d6e0ec3f6b01cf1aabb58b799ee88acf1a722e251807c9cb44e73a3e0</span></span><br></pre></td></tr></table></figure>

<h5 id="3-1-1-容器启动参数"><a href="#3-1-1-容器启动参数" class="headerlink" title="3.1.1 容器启动参数"></a>3.1.1 容器启动参数</h5><table>
<thead>
<tr>
<th>-d</th>
<th>以守护进程方式运行</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>指定映射端口</td>
</tr>
<tr>
<td>-P</td>
<td>随机映射端口</td>
</tr>
<tr>
<td>-i</td>
<td>保持标准输入打开</td>
</tr>
<tr>
<td>-t</td>
<td>分配一个伪终端</td>
</tr>
<tr>
<td>-v</td>
<td>设置挂载文件到主机上</td>
</tr>
<tr>
<td>–rm</td>
<td>当容器关闭时自动删除</td>
</tr>
<tr>
<td>–name</td>
<td>为启动的容器设置一个名字</td>
</tr>
<tr>
<td>–network</td>
<td>指定使用哪个网络</td>
</tr>
<tr>
<td>-e</td>
<td>设置容器中的环境变量</td>
</tr>
<tr>
<td>–link</td>
<td>链接到另一个容器</td>
</tr>
<tr>
<td>-h</td>
<td>指定容器内的主机名</td>
</tr>
</tbody></table>
<h4 id="3-2-停止容器"><a href="#3-2-停止容器" class="headerlink" title="3.2 停止容器"></a>3.2 停止容器</h4><p>Docker终止容器是首先向容器发送SIGTERM信号,等到一段时间超时后(默认10s),zaifasongSIGKILL信号来终止容器</p>
<p><img src="https://i.loli.net/2021/09/17/GrY2Ao6Fm3O7cWw.png" alt="image-20210917170901679"></p>
<p>这时候我们可以看到shadowbox已经被我们终止了, 还可以使用start命令开启这个容器</p>
<p><img src="https://i.loli.net/2021/09/17/Ua6JYk3VtNP5vzC.png" alt="image-20210917171015882"></p>
<h4 id="3-3-进入容器"><a href="#3-3-进入容器" class="headerlink" title="3.3 进入容器"></a>3.3 进入容器</h4><p>在使用容器的过程中, 我们难免需要进入容器进行排查问题. 下面有如下方式:</p>
<ul>
<li><p>attach</p>
<p>attach是最早docker官方推出的进入容器的命令,不过使用这个命令有一个问题,当多个窗口同时使用这个命令的时候,所有的窗口都会同步显示. 如果有一个窗口阻塞了,那么其他窗口也无法在进行操作,当所有窗口退出时,容器结束</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Linux ~]<span class="comment"># docker attach nginx127.0.0.1 - &quot;GET / HTTP/1.1&quot; 308 171 &quot;-&quot; &quot;curl/7.59.0&quot; 0.000 - .</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>exec</p>
<p>继attach之后,exec是官方推出的一个新的命令进入容器的方式,这个命令相当于在容器中执行一个命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Linux ~]<span class="comment"># docker exec -it nginx /bin/bashnginx [ / ]$nginx [ / ]$</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>nsenter</p>
<p>需要配合docker inspect来使用(早期的时候没有exec命令,企业中最常用的方式之一),Docker是使用golang语言开发的,所以他也支持go语言的模板语法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Linux ~]<span class="comment"># nsenter --target $( docker inspect -f &#123;&#123;.State.Pid&#125;&#125; nginxv1 ) --mount --uts --ipc --net --pidmesg: ttyname failed: No such deviceroot@6f99ae8757f7:/#</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ssh</p>
<p>在生产环境当中排除了使用docker attach命令进入容器之后,相信大家第一个想到的就是ssh. 在镜像或容器中安装ssh server, 这样就能保证多人进入容器并且相互之间不受干扰了,相信大家在之前的生产环境中(没有使用docker的情况)也是这样做的. 但是使用了docker容器之后不建议使用ssh进入docker容器中.</p>
<blockquote>
<p><strong>总结:</strong></p>
<p>进入docker container中一般情况下有4种范式,最常用的方式是exec和nsenter这两种.</p>
<p><strong>nsenter和exec之间的区别</strong></p>
<ul>
<li>exec是docker自带的命令,nsenter是Linux提供的命令</li>
<li>exec相当于在容器中执行一个命令,而nsenter仅仅是进入某一个容器而已</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="3-4-删除容器"><a href="#3-4-删除容器" class="headerlink" title="3.4 删除容器"></a>3.4 删除容器</h4><p>可以使用docker rm来删除容器</p>
<p>格式: <code>docker rm contaier</code></p>
<ul>
<li><p>强制删除 -f</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f nginx</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-5-导入导出容器"><a href="#3-5-导入导出容器" class="headerlink" title="3.5 导入导出容器"></a>3.5 导入导出容器</h4><p>某些时候需要将容器从一个系统迁移到另外一个系统,此时可以使用docker的导入和导出功能,这就是docker自身提供的一个重要特性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> [<span class="built_in">id</span>] &gt; name.tardocker import name.tar <span class="built_in">test</span>/name:v1</span><br></pre></td></tr></table></figure>

<p>实际上,即可以使用docker load命令来导入镜像文件到本地镜像库,也可以使用docker [container] import 命令, 这两者的区别就在于是否丢弃历史记录和元数据信息</p>
<h4 id="3-6-查看容器"><a href="#3-6-查看容器" class="headerlink" title="3.6 查看容器"></a>3.6 查看容器</h4><p>格式:</p>
<p><code>docker container inspact [options] CONTAINER [CONTAINER ...]</code>子命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Linux~]<span class="comment"># docker inspect k8s[    &#123;        &quot;Id&quot;: &quot;726b695a337c63b2ba617ed282171dff82a3d51cc0bdc43194ce63beaf656c38&quot;,        &quot;Created&quot;: &quot;2020-11-16T04:05:53.271281122Z&quot;,        &quot;Path&quot;: &quot;docker-entrypoint.sh&quot;,        &quot;Args&quot;: [            &quot;./start&quot;            ...            ],    &#125;]</span></span><br></pre></td></tr></table></figure>

<h4 id="3-7-容器命令详解"><a href="#3-7-容器命令详解" class="headerlink" title="3.7 容器命令详解"></a>3.7 容器命令详解</h4><ul>
<li><p>复制命令</p>
<p>复制命令类似于Linux系统中的scp命令, 是将宿主主机上的内容上传到容器中给你,也可能是将容器中的文件下载到宿主主机当中国n</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器中的内容复制到宿主主机[root@Linux ~]# docker cp 762b695a337c:/opt/start .[root@Linux ~]# ls | grep startStart# 将宿主主机中的文件复制到容器中[root@Linux ~]# docker cp start 762b695a337c:/root[root@Linux ~]# docker exec 762b695a337c ls /root</span></span><br></pre></td></tr></table></figure></li>
</ul>

  </article>
  <footer class="f-cf">
    
      <a href="/2021/11/02/%E4%BD%BF%E7%94%A8%E6%BA%90%E7%A0%81%E5%8D%87%E7%BA%A7%20openssh-%E4%BD%BF%E7%94%A8%E6%BA%90%E7%A0%81%E5%8D%87%E7%BA%A7openssh/" class="link f-fl">⟵使用源码升级 openssh</a>
    
    
      <a href="/2021/09/25/%E6%9C%89%E5%85%B3mysql80%20%E6%8E%88%E6%9D%83%E6%97%B6%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98-%E6%9C%89%E5%85%B3mysql80%E6%8E%88%E6%9D%83%E6%97%B6%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/" class="link f-fr">有关mysql8.0 授权时没有权限问题⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  d.guangying@foxmail.com
  
    
      
        · <a href="https://dribbble.com/clovertuan" target="_blank" class="nav-icn">Dribbble</a>
      
    
      
        · <a href="https://www.behance.net/clovertuan" target="_blank" class="nav-icn">Behance</a>
      
    
      
        · <a href="http://clovertuan.lofter.com/" target="_blank" class="nav-icn">Lofter</a>
      
    
      
        · <a href="https://www.instagram.com/clovertuan/" target="_blank" class="nav-icn">Instagram</a>
      
    
      
        · <a href="https://github.com/cloverTuan" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @Clover Tuan</span>
</footer>
  </div>
</body>
</html>